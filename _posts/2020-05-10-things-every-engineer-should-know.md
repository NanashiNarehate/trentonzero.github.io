---
published: false
layout: post
category: personal
tags:
  - programming
title: 150 Things Every Software Engineer Should Know
---

1. 0(n log n)
2. How to hash a data structure
3. When to use a hashmap
4. When to use an array
5. When *not* to use an array
6. [1..100].map(addOne)
7. [1..100].reduce(sum)
8. Why you can't string append in a loop 
9. That the next time after 1:59 is not 2:00
10. Why "float accountBalance = 100.32" is a bug
11. How to write a recursive algorithm
12. When to write a recursive algoritm
13. What tail call optimization is
14. How a compiler works
15. O(1)
16. Why was OO invented?
17. Why do some engineers hate LISP?
18. Why do some engineers swear by LISP?
19. Why do some engineers hate OO?
20. Why do some engineers swear by OO?
21. How to switch between normal and insert mode in Vi
22. How to save in Vi
23. Why is there are a long-running flame war between vi and emacs
24. What is the visitor pattern
25. How does a buffer overflow exploit work
26. What does a buffer overflow exploit look like in code
27. How does garbage collection work
28. How does double buffering work
29. How does DNS work
30. What it feels like when it is harder than it should be
31. What does cyclomatic complexity measure? 
32. Why does high cyclomatic complexity imply buggy code?
33. How to spot buggy code using only whitespace
34. Why do some engineers swear by spaces?
35. Why do some engineers swear by tabs?
36. How to debug with a rubber ducky
37. What is TCP and why would you use it?
38. What is UDP and why would you use it?
39. What is a password salt and why do you use it?
40. How do random number generators work?
41. When to build a graph?
42. What happens when you git rebase?
43. When happens when you git merge?
44. What is fast-forward in git?
45. What really happens when you revert a merge commit in git?
46. Why are the estimates always wrong?
47. What is the million-man-hour myth?
48. Which side of the modal dialog the cancel button goes on
49. When *not* to show a modal dialog
50. What is a screen reader
51. How do you implement and train a neural network
52. An algorithm that sorts in less than O(n<sup>2</sup>)
53. How to sort a binary tree
54. What features allow NoSQL databases to scale horizontally better than SQL databases
55. What features do NoSQL databases sacrifice from SQL databases
56. ACID vs BASE
57. How deadlocks happen
58. What Turing Completeness proves
59. What it doesn't prove
60. Dependency injection
61. The two general's problem
62. How much latency feels instantaneous
63. how much latency feels fast
64. slow
65. how much latency before the user gives up
66. why you never run a cron job every five minutes in a distributed system
67. that the user doesn't know what he wants
68. how to tell what the user actually wants
69. what your boss really wants
70. the cost of your program crashing
71. what a new user sees when he starts your program
72. what your grandmother sees
73. how to explain why a feature is difficult or impossible in words an MBA can understand
74. in words your grandmother can understand
75. in words an arrogant junior engineer can understand
76. what each of these people really wants when they ask for the impossible feature
77. that easy-to-learn tools usually increase project complexity
78. that hard-to-learn tools usually decrease project omplexity
79. why hardware manufacturers invest billions in open source
80. how Bill Gates made his billions
81. the business model of a successful open source product
82. what marginal cost says about software as a business
83. what marginal cost says about open source software
84. why most of the highest quality software in the world costs $50-$200 per license.
85. why the lowest quality software in the world costs $1,000-$100,000 per license.
86. when to ask for help
87. when to add a third party dependency
88. when to roll your own
89. when to ignore the contractor
90. and when to defer to her
91. grep
92. grep -v
93. what Chesterton's fence says about legacy code
94. Be fluent in a dynamically typed language
95. ...a statically typed language
96. ...an object oriented language
97. ...a functional language
98. ...a scripting language
99. C
100. LISP macros
101. how to implement a hobby language of each of these types in C
102. what it feels like to return to bad code after 6 months away
103. what the web is like at 56k
104. what the web is like on a screen reader
105. why regex cannot model XML
106. Each type of SQL join
107. its performance
108. its treatment of missing data
109. that Object-Relational mapping is impossible
110. That sometimes impossible things are worth almost doing
111. Nothing is easy
112. You need sleep to live
113. Your skills are probably worth more than you think
114. That engineers are taken out and shot at 40
115. How and when to optimize for CPU cycles
116. How and when to optimize for memory
117. How and when to optimize for latency
118. That usually it's best not to optimize at all
119. How to optimize for free time
120. How to optimize for family
121. How to optimize for low bug counts
122. How to ask for a raise
123. How and why to avoid a bad software team
124. You need exercise to live
125. That you will desperately want a non-computer hobby by your mid-30s.
126. All that stuff about good computer posture applies to you. 
127. The Gang of Four Design Patterns
128. The Unix Philosophy
129. Why engineers still use tools written the Unix way decades later
130. Why everything for end-users written the Unix way is dead and bankrupt.
131. What you sound like as a bright young engineer to the old timers
132. What the old timers sound like to a bright young engineer.
133. Why it seems like marketing never does any work
134. Why your blue-collar cousin thinks you don't do any work
135. Why so many engineers hate Java
136. Why so many businesses use Java
137. What an architecture astronaut is
138. What a network effect is
139. Commodification
140. Promises
141. How to search a 100kb file for a string?
142. A 2 terabyte file
143. In ISO-8859-1
144. How to ensure only one copy of your program is running
145. Why email isn't secure
146. The implications of the major open source licenses for commercial software development
147. What a Heisenbug is
148. How to debug it
149. How to avoid it
150. What a race condition is 
and what it looks like in code.





( This was inspired by ["Two Hundred and Fifty Things an Architect Should Know" by Michael Sorkin](https://www.readingdesign.org/250-things?fbclid=IwAR1QkzCBRB1X2k45QTrJGI1otGGyg8MXYQfZUSlosF2L_ejTuRyqbeGNrzE) )
