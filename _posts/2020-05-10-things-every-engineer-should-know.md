---
published: false
layout: post
category: personal
tags:
  - programming
title: 250 Things Every Software Engineer Should Know
---

1. 0(n log n)
2. How to hash a data structure
3. When to use a hashmap
4. When to use an array
5. When *not* to use an array
6. [1..100].map(addOne)
7. [1..100].reduce(sum)
8. Why you can't string append in a loop 
9. That the next time after 1:59 is not 2:00
10. Why "float accountBalance = 100.32" is a bug
11. How to write a recursive algorithm
12. When to write a recursive algoritm
13. What tail call optimization is
14. How a compiler works
15. O(1)
16. Why was OO invented?
17. Why do some engineers hate LISP?
18. Why do some engineers swear by LISP?
19. Why do some engineers hate OO?
20. Why do some engineers swear by OO?
21. How to switch between normal and insert mode in Vi
22. How to save in Vi
23. Why is there are a long-running flame war between vi and emacs
24. What is the visitor pattern
25. How does a buffer overflow exploit work
26. What does a buffer overflow exploit look like in code
27. How does garbage collection work
28. How does double buffering work
29. How does DNS work
30. What it feels like when it is harder than it should be
31. What does cyclomatic complexity measure? 
32. Why does high cyclomatic complexity imply buggy code?
33. How to spot buggy code using only whitespace
34. Why do some engineers swear by spaces?
35. Why do some engineers swear by tabs?
36. How to debug with a rubber ducky
37. What is TCP and why would you use it?
38. What is UDP and why would you use it?
39. What is a password salt and why do you use it?
40. How do random number generators work?
41. When to build a graph?
42. What happens when you git rebase?
43. When happens when you git merge?
44. What is fast-forward in git?
45. What really happens when you revert a merge commit in git?
46. Why are the estimates always wrong?
47. What is the million-man-hour myth?
48. Which side of the modal dialog the cancel button goes on
49. When *not* to show a modal dialog
50. What is a screen reader
51. How do you implement and train a neural network
52. An algorithm that sorts in less than O(n<sup>2</sup>)
53. How to sort a binary tree
54. What features allow NoSQL databases to scale horizontally better than SQL databases
55. What features do NoSQL databases sacrifice from SQL databases
56. ACID vs BASE
57. How deadlocks happen
58. What Turing Completeness proves
59. What it doesn't prove
60. Dependency injection
61. The two general's problem
62. How much latency feels instantaneous
63. how much latency feels fast
64. slow
65. how much latency before the user gives up
66. why you never run a cron job every five minutes in a distributed system
67. that the user doesn't know what he wants
68. how to tell what the user actually wants
69. what your boss really wants
70. the cost of your program crashing
71. what a new user sees when he starts your program
72. what your grandmother sees
73. how to explain why a feature is difficult or impossible in words an MBA can understand
74. in words your grandmother can understand
75. in words an arrogant junior engineer can understand
76. what each of these people really wants when they ask for the impossible feature
77. that easy-to-learn tools usually increase project complexity
78. that hard-to-learn tools usually decrease project omplexity
79. why hardware manufacturers invest billions in open source
80. how Bill Gates made his billions
81. the business model of a successful open source product
82. marginal costs



( This was inspired by ["Two Hundred and Fifty Things an Architect Should Know" by Michael Sorkin](https://www.readingdesign.org/250-things?fbclid=IwAR1QkzCBRB1X2k45QTrJGI1otGGyg8MXYQfZUSlosF2L_ejTuRyqbeGNrzE) )
